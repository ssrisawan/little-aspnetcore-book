## นำส่งด้วยดอคเกอร์

หากคุณไม่ได้ใช้แพลตฟอร์มเช่นอาชัวร์ ก็สามารถใช้เทคโนโลยคอนเทนเนอร์เช่นดอคเกอร์มาช่วยในการนำส่งเว็บแอปพลิเคชันขึ้นไปยังเครื่องเซอร์ฟเวอร์ของคุณเองได้ แทนที่จะต้องเสียเวลาตั้งค่าเซอร์ฟเวอร์พร้อมทั้งจัดเตรียมสิ่งต่าง ๆ ที่จำเป็นต่อการรันแอป คัดลอกไฟล์ที่ต้องใช้ รวมถึงการรีสตาร์ทโปรเซสต่าง ๆ คุณสามารถสร้างดอคเกอร์อิมเมจที่จัดเตรียมทุกอย่างที่จำเป็นต่อแอปพลิเคชันไว้ แล้วนำขึ้นไปทำงานเป็นคอนเทนเนอร์บนโฮสต์ใดก็ได้ที่รองรับดอคเกอร์

ดอคเกอร์ยังช่วยให้การสเกลแอปพลิเคชันไปทำงานข้ามหลายเซอร์ฟเวอร์ง่ายขึ้นอีกด้วย เมื่อมีอิมเมจพร้อมใช้งานแล้ว ไม่ว่าจะสร้างเพียง 1 คอนเทนเนอร์หรือ 100 คอนเทนเนอร์ ก็สามารถทำได้โดยใช้ขั้นตอนแบบเดียวกัน

ก่อนเริ่มการทำงาน เราต้องมี CLI ของดอคเกอร์ติดตั้งในเครื่องที่ใช้ในการพัฒนาเสียก่อน ให้ค้นหาด้วย "get docker for (mac/windows/linux)" แล้วทำตามขั้นตอนที่แสดงไว้บนเว็บไซต์ทางการของดอคเกอร์ เราสามารถตรวจสอบได้ว่าการติดตั้งเป็นไปอย่างถูกต้องหรือไม่ด้วยคำสั่ง

```
docker version
```

### เพิ่ม Dockerfile

สิ่งแรกที่เราจำเป็นต้องใช้คือ Dockerfile ซึ่งเป็นดั่งสูตรที่บอกให้ดอคเกอร์รู้ว่าต้องใช้อะไรบ้างเพื่อสร้างและรันแอปพลิเคชันของเรา

ให้สร้างไฟล์ชื่อ `Dockerfile` (ไม่มีส่วนขยาย) ในโฟลเดอร์ `AspNetCoreTodo` ที่เป็นรากหรือระดับบนสุด จากนั้นให้เปิดในโปรแกรมแก้ไขข้อความที่คุณถนัดแล้วเขียนบรรทัดต่อไปนี้:

```dockerfile
FROM microsoft/dotnet:2.0-sdk AS build
```

ซึ่งจะบอกให้ดอคเกอร์ใช้อิมเมจ `microsoft/dotnet:2.0-sdk` เป็นจุดเริ่มต้น อิมเมจนี้เผยแพร่โดยไมโครซอฟต์และมีเครื่องมีอและสิ่งที่จำเป็นต้องใช้สำหรับการทำงานของ `dotnet build` และการคอมไพล์แอปพลิเคชัน การใช้อิมเมจพร้อมใช้เช่นนี้เป็นจุดเริ่มต้นช่วยให้ดอคเกอร์สามารถปรับเปลี่ยนอิมเมจให้เหมาะสมกับแอปของเรา รวมทั้งทำให้แอปมีขนาดเล็กได้

ลำดับต่อไป ให้เพิ่มบรรทัดนี้:

```dockerfile
COPY AspNetCoreTodo/*.csproj ./app/AspNetCoreTodo/
```

คำสั่ง `COPY` คัดลอกไฟล์โปรเจกต์ `.csproj` เข้าไปไว้ที่เส้นทาง `/app/AspNetCoreTodo/` ในอิมเมจ สังเกตว่ายังไม่มีไฟล์ของโค้ดใด ๆ (ไฟล์ `.cs`) ถูกคัดลอกไปยังอิมเมจเลย ซึ่งเราจะทราบเหตุผลในเร็ว ๆ นี้

```dockerfile
WORKDIR /app/AspNetCoreTodo
RUN dotnet restore
```

`WORKDIR` เป็นคำสั่งดอคเกอร์ที่เปรียบได้กับ `cd` นั่นหมายความว่าคำสั่งใด ๆ ที่ทำหลังจากนั้นจะถูกกระทำจากภายใต้ไดเรกทอรี `/app/AspNetCoreTodo` ซึ่งถูกสร้างด้วยคำสั่ง `COPY` ในขั้นตอนที่แล้ว

การรันคำสั่ง `dotnet restore` จะเรียกคืนแพคเกจ NuGet ที่ต้องใช้ในแอปพลิเคชันและถูกกำหนดไว้ในไฟล์ `.csproj`ซึ่งการเรียกคืนแพคเกจในอิมเมจ **ก่อน** เพิ่มโค้ดส่วนที่เหลือเช่นนี้จะช่วยให้ดอคเกอร์แคชแพคเกจที่ถูกเรียกคืนเอาไว้ หลังจากนี้หากเราแก้ไขโค้ด (แต่ไม่ได้เปลี่ยนแพคเกจที่ถูกกำหนดไว้ในไฟล์โปรเจกต์) การสร้างอิมเมจของดอคเกอร์ขึ้นมาใหม่จะทำได้อย่างรวดเร็วมาก

ตอนนี้ก็ถึงเวลาที่จะคัดลอกโค้ดที่เหลือและคอมไพล์แอปพลิเคชันแล้ว:

```dockerfile
COPY AspNetCoreTodo/. ./AspNetCoreTodo/
RUN dotnet publish -o out /p:PublishWithAspNetCoreTargetManifest="false"
```

คำสั่ง `dotnet publish` จะคอมไพล์โปรเจกต์และแฟลก `-o out` จะทำให้ไฟล์ที่ถูกคอมไพล์แล้วถูกนำไปไว้ในไดเรกทอรีที่ชื่อ `out`

ไฟล์ที่ถูกคอมไพล์ไว้เหล่านี้จะถูกใช้เพื่อรันแอปพลิเคชันด้วยคำสั่งต่อไปนี้:

```dockerfile
FROM microsoft/dotnet:2.0-runtime AS runtime
ENV ASPNETCORE_URLS http://+:80
WORKDIR /app
COPY --from=build /app/AspNetCoreTodo/out ./
ENTRYPOINT ["dotnet", "AspNetCoreTodo.dll"]
```

คำสั่ง `FROM` ถูกใช้อีกครั้งเพื่อเลือกอิมเมจที่มีขนาดเล็กที่มีเฉพาะสิ่งที่จำเป็นต่อการรันแอปพลิเคชัน คำสั่ง `ENV` ถูกใช้เพื่อกำหนดตัวแปรสภาพแวดล้อมในคอนเทนเนอร์ และตัวแปรสภาพแวดล้อม `ASPNETCORE_URLS` จะบอก ASP.NET Core ว่าควรเชื่อมเข้ากับอินเตอร์เฟสเครือข่ายและพอร์ตใด (ซึ่งในที่นี้คือพอร์ต 80)

คำสั่ง `ENTRYPOINT` บอกให้ดอคเกอร์รู้ว่าคอนเทนเนอร์ควรถูกเริ่มการทำงานด้วยการรัน `dotnet AspNetCoreTodo.dll` ซึ่งบอกให้ `dotnet` เริ่มแอปพลิเคชันของเราจากไฟล์ที่ถูกคอมไพล์ขึ้นมาก่อนหน้านี้โดย `dotnet publish`  (เราได้ทำสิ่งเดียวกันนี้ระหว่างการพัฒนาด้วยการสั่ง `dotnet run` เพียงขั้นตอนเดียว)

ไฟล์ Dockerfile ที่สมบูรณ์จะมีลักษณะดังนี้:

**Dockerfile**

```dockerfile
FROM microsoft/dotnet:2.0-sdk AS build
COPY AspNetCoreTodo/*.csproj ./app/AspNetCoreTodo/
WORKDIR /app/AspNetCoreTodo
RUN dotnet restore

COPY AspNetCoreTodo/. ./
RUN dotnet publish -o out /p:PublishWithAspNetCoreTargetManifest="false"

FROM microsoft/dotnet:2.0-runtime AS runtime
ENV ASPNETCORE_URLS http://+:80
WORKDIR /app
COPY --from=build /app/AspNetCoreTodo/out ./
ENTRYPOINT ["dotnet", "AspNetCoreTodo.dll"]
```

### สร้างอิมเมจ

ตรวจสอบให้แน่ใจว่า Dockerfile ถูกบันทึกไว้แล้ว จากนั้นให้ใช้คำสั่ง `docker build` เพื่อสร้างอิมเมจ:

```
docker build -t aspnetcoretodo .
```

อย่าลืมว่าต้องมีจุดต่อท้าย! จุดนี้บอกให้ดอคเกอร์รู้ว่าต้องมองหา Dockerfile ในไดเรกทอรีปัจจุบัน

หลังจากอิมเมจถูกสร้างขึ้นแล้ว เราสามารถรัน `docker images` เพื่อแสดงรายการอิมเมจทั้งหมดในเครื่องของเราได้ เพื่อทดสอบการทำงานในคอนเทนเนอร์ ให้รัน

```
docker run --name aspnetcoretodo_sample --rm -it -p 8080:80 aspnetcoretodo
```

แฟลก `-it` บอกดอคเกอร์ใหรันคอนเทนเนอร์ในโหมดโต้ตอบ (แสดงผลการรันบนเทอร์มินัลแทนที่จะรันอยู่เบื้องหลัง) เมื่อต้องการหยุดการทำงานของคอนเทนเนอร์ให้กด Control-C

จำตัวแปร `ASPNETCORE_URLS` ที่บอกให้ ASP.NET Core คอยรับการเชื่อมต่อที่พอร์ต 80 ได้ไหม ตัวเลือก `-p 8080:80` บอกดอคเกอร์ให้จับคู่พอร์ต 8080 บน *เครื่องของเรา* เข้ากับพอร์ต 80 ของ *คอนเทนเนอร์* ให้เปิดเบราว์เซอร์ไปที่ http://localhost:8080 ก็จะพบแอปพลิเคชันของเราที่ทำงานอยู่บนคอนเทนเนอร์!

### จัดเตรียม Nginx

ดังที่ได้กล่าวแล้วเมื่อตอนต้นของบทนี้ว่าเราควรใช้รีเวิร์สพรอกซีเช่น Nginx เพื่อส่งต่อคำขอไปยังเคสเตรล เราสามารถใช้ดอคเกอร์เพื่อดำเนินการนี้ได้เช่นกัน

โดยภาพรวมแล้ว สถาปัตยกรรมนี้จะประกอบด้วยสองคอนเทนเนอร์: คอนเทนเนอร์ Nginx คอยรับการเชื่อมต่อที่พอร์ต 80 แล้วส่งต่อคำขอไปยังคอนเทนเนอร์ที่เราเพิ่งสร้างขึ้นมาที่รันแอปพลิเคชันของเราอยู่บนเคสเตรล

คอนเทนเนอร์ Nginx ต้องใช้ Dockerfile ของตัวเอง ดังนั้นเพื่อหลีกเลี่ยงความสับสนที่อาจเกิดขึ้นกับ Dockerfile ที่เพิ่งถูกสร้างขึ้น ให้สร้างไดเรกทอรีใหม่ขึ้นมาที่รากของเว็บแอปพลิเคชัน:

```
mkdir nginx
```

สร้าง Dockerfile ขึ้นมาใหม่ แล้วเพิ่มบรรทัดต่อไปนี้:

**nginx/Dockerfile**

```dockerfile
FROM nginx
COPY nginx.conf /etc/nginx/nginx.conf
```

จากนั้น ให้สร้างไฟล์ `nginx.conf`:

**nginx/nginx.conf**

```
events { worker_connections 1024; }

http {
    server {
        listen 80;
        location / {
          proxy_pass http://kestrel:80;
          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection 'keep-alive';
          proxy_set_header Host $host;
          proxy_cache_bypass $http_upgrade;
        }
    }
}
```

ไฟล์โครงแบบนี้บอก Nginx ให้ส่งต่อคำขอไปยัง `http://kestrel:80` (อีกสักครู่ เราจะทราบว่าเหตุใด `kestrel` จึงใช้แทนชื่อโฮสต์ได้)

> ขณะนำส่งแอปพลิเคชันของเราขึ้นไปบนสภาพแวดล้อมที่ใช้งานจริงแล้ว เราควรเพิ่มคำชี้แจง `server_name`เพื่อตรวจสอบและจำกัดให้ใช้ได้เฉพาะโฮสต์เฮดเดอร์ที่กำหนดเท่านั้น รายละเอียดเพิ่มเติมสามารถดูได้ที่:

> https://github.com/aspnet/Announcements/issues/295

### จัดเตรียม Docker Compose

ยังมีอีกไฟล์ที่จำเป็นต้องใช้ ให้ย้อนกลับไปยังไดเรกทอรีราก แล้วสร้าง `docker-compose.yml`:

**docker-compose.yml**

```yaml
nginx:
    build: ./nginx
    links:
        - kestrel:kestrel
    ports:
        - "80:80"
kestrel:
    build: .
    ports:
        - "80"
```

Docker Compose เป็นเครื่องมือที่ช่วยให้เราสร้างและรันแอปพลิเคชันแบบหลายคอนเทนเนอร์ได้ ไฟล์โครงแบบนี้กำหนดสองคอนเทนเนอร์ขึ้นมา: `nginx` จากสูตรใน `./nginx/Dockerfile` และ `kestrel` จากสูตรใน `./Dockerfile` เนื่องจากทั้งสองคอนเทนเนอร์ถูกเชื่อมโยงกันไว้อย่างชัดเจนจึงสามารถสื่อสารกันได้

เราสามารถเริ่มการทำงานของแอปพลิเคชันแบบหลายคอนเทนเนอร์ได้ด้วยการรัน:

```
docker-compose up
```

ลองเปิดเบราว์เซอร์แล้วไปที่ http://localhost (ที่พอร์ต 80 ไม่ใช่ 8080!) Nginx จะคอยรับการเชื่อมต่ออยู่ที่พอร์ต 80 (พอร์ตตั้งต้นของ HTTP) และส่งต่อคำขอไปยังแอปพลิเคชัน ASP.NET Core ของเราที่ทำงานอยู่บนเคสเตรล

### จัดเตรียมเซอร์ฟเวอร์ดอคเกอร์

ขั้นตอนการติดตั้งโดยเฉพาะอยู่นอกเหนือขอบเขตของหนังสือเล่มมนี้ แต่ลินุกซ์รุ่นใหม่ ๆ จากทุกค่าย (เช่น Ubuntu) สามารถนำมาใช้เป็นโฮสต์สำหรับดอคเกอร์ได้ ตัวอย่างเช่นเราสามารถสร้างเวอร์ชวลแมชชีนด้วย Amazon EC2 แล้วติดตั้งบริการดอคเกอร์ (ตัวอย่างเช่น) คุณอาจลองค้นหาขั้นตอนการทำงานดังกล่าวด้วย "amazon ec2 set up docker" ก็ได้

โดยส่วนตัวแล้ว ผู้เขียนนิยมใช้ DigitalOcean เนื่องจากสามารถเริ่มทำงานได้ง่ายมาก ๆ โดย DigitalOcean มีทั้งเวอร์ชวลแมชชีนสำหรับดอคเกอร์ที่ถูกสร้างไว้แล้วให้พร้อมใช้งาน รวมทั้งคู่มือและขั้นตอนโดยละเอียดสำหรับการทำงานด้วยดอคเกอร์ (ค้นหาด้วย "digitalocean docker")
