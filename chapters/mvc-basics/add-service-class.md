## เพิ่มคลาสบริการ (service class)
คุณได้สร้าง model, view และ controller ขึ้นมาแล้ว แต่ก่อนที่คุณจะใช้ model และ view ใน controller ได้ คุณจำเป็นต้องเขียนโค้ดที่จะนำข้อมูลรายการสิ่งที่ต้องทำขึ้นมาจากฐานข้อมูลเสียก่อน

ถึงคุณสามารถเขียนโค้ดสำหรับฐานข้อมูลใน controller ได้โดยตรง แต่ตามแนวปฏิบัติที่ดีแล้ว การแยกโค้ดออกจากกันจะเป็นวิธีที่ดีกว่า ทำไมน่ะหรือ? เพราะในแอปพลิเคชันใหญ่ ๆ ที่ใช้งานจริง มีหลายประเด็นที่ค้องคำนึงถึง เช่น:

* **การสร้าง view** และรองรับข้อมูลนำเข้า: ซึ่งเป็นส่วนที่รับผิดชอบโดย controller ของคุณอยู่แล้ว
* **ดำเนินการตามตรรกะทางธุรกิจ** หรือโค้ดและตรรกะที่สอดคล้องกับวัตถุประสงค์และ "ธุรกิจ" ของแอปพลิเคชันของคุณ ซึ่งในแอปพลิเคชันรายการสิ่งที่ต้องทำนี้ ตรรกะทางธุรกิจหมายถึงการตัดสินใจต่าง ๆ เช่น การกำหนดค่าตั้งต้นสำหรับวันครบกำหนดของกิจกรรม และการตัดสินใจว่าจะให้แสดงเฉพาะรายการงานที่ยังไม่แล้วเสร็จ เป็นต้น ตัวอย่างอื่น ๆ ของตรรกะทางธุรกิจ เช่น การคำนวณหาต้นทุนทั้งหมดโดยดูจากราคาสินค้าและอัตราภาษีที่เกี่ยวข้อง หรือการตรวจสอบว่าผู้เล่นมีคะแนนเพียงพอที่จะเลื่อนระดับชั้นในเกมแล้วหรือยัง
* **การบันทึกและการเรียกข้อมูล** รายการต่าง ๆ จากฐานข้อมูล

ดังที่กล่าวแล้วว่าเราสามารถดำเนินการทั้งหมดข้างต้นจาก controller ขนาดใหญ่เพียงตัวเดียวได้ แต่จะทำให้การจัดการและการทดสอบกระทำได้ยากเกินไป ดังนั้นเราจึงพบเห็นแอปพลิเคชันที่ถูกแบ่งออกเป็นสองถึงสามชั้น (เรียกว่า layer หรือ tier) หรือมากกว่า โดยแต่ละชั้นทำหน้าที่รองรับเพียงหนึ่งประเด็นเท่านั้น ซึ่งช่วยให้ controller คงความเรียบง่ายได้มากที่สุดที่เป็นไปได้ และช่วยให้การทดสอบ การแก้ไขกระบวนการทางธุรกิจตลอดจนการเขียนโค้ดสำหรับฐานข้อมูลในลำดับต่อไปสามารถกระทำได้ง่ายขึ้น

การแบ่งแอปพลิเคชันออกเป็นหลายชั้นอาจเรียกได้ว่าเป็นแบบ **multi-tier** หรือ **สถาปัตยกรรมแบบ n-tier** ในบางครั้ง แต่ละชั้น (tier หรือ layer) เหล่านี้อาจแยกออกเป็นแต่ละโปรเจกต์ของตนเอง แต่โดยทั่วไปก็เป็นเพียงการจัดแบ่งออกเป้นคลาสต่าง ๆ เท่านั้น สิ่งสำคัญคือการคิดว่าจะแบ่งแอปพลิเคชันออกเป็นส่วนย่อย ๆ ที่สามารถจัดการได้ง่ายได้อย่างไร และพยายามหลีกเลี่ยงการใช้ controller หรือคลาสขนาดใหญ่ที่พยายามทำทุกอย่างด้วยตนเอง

ในโปรเจกต์นี้ เราจะแบ่งแอปพลิเคชันออกเป็นสองชั้น: **ชั้นนำเสนอ (presentation layer)** ประกอบด้วย controller และ view ต่าง ๆ ที่โต้ตอบกับผู้ใช้ และ **ชั้นบริการ (service layer)** ที่มีส่วนของตรรกะทางธุรกิจและโค้ดสำหรับฐานข้อมูล ในตอนนี้เรามีชั้นนำเสนออยู่แล้ว ดังนั้น ขั้นตอนต่อไปคือการสร้างบริการเพื่อรองรับตรรกะทางธุรกิจของสิ่งที่ต้องทำและบันทึกรายการสิ่งที่ต้องทำเหล่านั้นลงในฐานข้อมูล

> โปรเจกต์ขนาดใหญ่ส่วนมากมักใช้สถาปัตยกรรมแบบ 3-tier: ชั้นนำเสนอ, ชั้นตรรกะสำหรับบริการ และชั้นคลังเก็บข้อมูล (data repository layer) **คลังเก็บ (repository)** เป็นคลาสที่มุ่งทำงานในส่วนของโค้ดฐานข้อมูลเพียงด้านเดียว (ไม่มีตรรกะทางธุรกิจ) แต่ในแอปพลิเคชันนี้ เราจะรวมส่วนนี้เข้าด้วยกันเป็นชั้นบริการเพียงชั้นเดียวเพื่อให้เข้าใจง่าย แต่คุณอาจทดลองวางโครงสร้างของโค้ดในรูปแบบอื่นก็ได้ตามต้องการ

### สร้างอินเตอร์เฟส

ภาษา C# ได้รวมแนวคิดของ **อินเตอร์เฟส (interfaces)** เอาไว้ หลักของแนวคิดนี้คือการที่เมธอดและคุณสมบัติต่าง ๆ ของวัตถุถูกแยกออกจากคลาสที่มีโค้ดสำหรับเมธอดและคุณสมบัติเหล่านั้น อินเตอร์เฟสช่วยให้สามารถแยกส่วนคลาสต่าง ๆ ออกจากกันรวมทั้งสามารถทำการทดสอบได้โดยง่ายดังที่คุณจะได้เห็นต่อไปนี้ (และอีกครั้งในบท *การทดสอบโดยอัตโนมัติ*) ซึ่งคุณจะได้ใช้อินเตอร์เฟสมาทำหน้าที่แทนบริการที่สามารถโต้ตอบกับรายการสิ่งที่ต้องทำในฐานข้อมูลได้

โดยธรรมเนียมปฏิบัติแล้ว ชื่ออินเตอร์เฟสจะนำหน้าด้วย "I" ดังนั้นเราจะสร้างไฟล์ในไดเรกทอรี Services โดยมีรายละเอียดดังนี้:

**Services/ITodoItemService.cs**

```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using AspNetCoreTodo.Models;

namespace AspNetCoreTodo.Services
{
    public interface ITodoItemService
    {
        Task<TodoItem[]> GetIncompleteItemsAsync();
    }
}
```

สังเกตว่าเนมสเปซ (namespace) ของไฟล์นี้คือ `AspNetCoreTodo.Services` เนมสเปซเหล่านี้เป็นวิธีการจัดการไฟล์ต่าง ๆ ของโค้ด .NET และตามธรรมเนียมของเนมสเปซแล้วจะต่อท้ายด้วยชื่อไดเรกทอรีที่ไฟล์นั้นถูกจัดเก็บไว้ (เช่นการใช้ `AspNetCoreTodo.Services` สำหรับแต่ละไฟล์ที่อยู่ในไดเรกทอรี `Services` เป็นต้น)

เนื่องจากไฟล์นี้ (ซึ่งอยู่ในเนมสเปซ `AspNetCoreTodo.Services`) อ้างอิงคลาส `TodoItem` (ที่อยู่ในเนมสเปซ `AspNetCoreTodo.Models`) จึงจำเป็นต้องใช้คำสั่ง `using` ที่ส่วนหัวของไฟล์เพื่อนำเข้าเนมสเปซดังกล่าว หากไม่ได้ระบุคำสั่ง `using` แล้ว จะเกิดข้อความแสดงความผิดพลาดว่าไม่พบชนิดของข้อมูลหรือเนมสเปซชื่อ 'TodoItem' ดังนี้:

```
The type or namespace name 'TodoItem' could not be found (are you missing a using directive or an assembly reference?)
```

เนื่องจากไฟล์นี้เป็นอินเตอร์เฟสจึงไม่มีโค้ดสำหรับการทำงานใด ๆ อยู่ในนี้ มีเพียงการกำหนดนิยาม (หรือลายเซ็นของเมธอด **method signature**) ของเมธอด `GetIncompleteItemsAsync` เท่านั้น โดยเมธอดนี้ไม่ต้องการพารามิเตอร์ใด ๆ และจะคืนค่าเป็น `Task<TodoItem[]>`

> หากไวยากรณ์นี้ดูซับซ้อนเกินไป ลองคิดว่านี่คือ: "งาน (task) หนึ่งที่มีค่าอาเรย์ของ TodoItems"

ชนิดของข้อมูล `Task` นี้เปรียบได้กับคำสัญญาหรือเป็นเรื่องของอนาคต ซึ่งถูกนำมาใช้ในที่นี้เนื่องจากเมธอดนี้จะเป็นแบบอะซิงโครนัส **asynchronous** หรืออีกนัยหนึ่งคือเมธอดนี้อาจไม่สามารถคืนค่ารายการสิ่งที่ต้องทำกลับมาให้ได้ทันทีเนื่องจากจะต้องสื่อสารกับฐานข้อมูลเสียก่อน (จะกล่าวถึงประเด็นนี้ต่อไปในภายหลัง)

### สร้างคลาสบริการ (service class)

หลังจากที่อินเตอร์เฟสได้ถูกกำหนดขึ้นมา เราก็พร้อมสำหรับการสร้างคลาสบริการกันแล้ว อย่างไรก็ตาม โค้ดสำหรับการทำงานกับฐานข้อมูลจะถูกกล่าวถึงโดยละเอียดในบท *การใช้ฐานข้อมูล* สำหรับตอนนี้ เราจะใช้ข้อมูลหลอกที่จะคืนค่ารายการสิ่งที่ต้องทำสองรายการที่ระบุไว้ในโค้ดทุกครั้งกันก่อน:

**Services/FakeTodoItemService.cs**

```csharp
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using AspNetCoreTodo.Models;

namespace AspNetCoreTodo.Services
{
    public class FakeTodoItemService : ITodoItemService
    {
        public Task<TodoItem[]> GetIncompleteItemsAsync()
        {
            var item1 = new TodoItem
            {
                Title = "Learn ASP.NET Core",
                DueAt = DateTimeOffset.Now.AddDays(1)
            };

            var item2 = new TodoItem
            {
                Title = "Build awesome apps",
                DueAt = DateTimeOffset.Now.AddDays(2)
            };

            return Task.FromResult(new[] { item1, item2 });
        }
    }
}
```

คลาส `FakeTodoItemService` นี้อิมพลีเมนต์อินเตอร์เฟส `ITodoItemService` แต่จะคืนค่าเป็นอาเรย์ของ `TodoItem` สองรายการอยู่เสมอ เราจะใช้คลาสนี้เพื่อทดสอบ controller และ view กันก่อน จากนั้นเราจึงจะเพิ่มโค้ดสำหรับฐานข้อมูลจริง ๆ กันในบท *การใช้ฐานข้อมูล*
