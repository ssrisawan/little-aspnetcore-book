## สร้างการโยกย้ายข้อมูล

การโยกย้ายข้อมูล (migration) ช่วยติดตามการเปลี่ยนแปลงโครงสร้างของฐานข้อมูลตามช่วงเวลา และช่วยให้สามารถยกเลิกหรือย้อนคืน (roll back) การเปลี่ยนแปลงดังกล่าว หรือใช้สร้างฐานข้อมูลขึ้นมาใหม่โดยใช้โครงสร้างเดียวกันกับฐานข้อมูลแรกได้ ด้วยการโยกย้ายข้อมูลเช่นนี้ เราจึงมีประวัติของการเปลี่ยนแปลงต่าง ๆ ทั้งหมด เช่นการเพิ่มหรือลบคอลัมน์ (หรือทั้งตาราง) เก็บไว้

ในบทที่แล้ว เราได้เพิ่มชุดของ `Items` เข้าไปในบริบท แต่เนื่องจากในขณะนี้บริบทของเรามีชุดของข้อมูล (หรือตาราง) ที่ยังไม่มีในฐานข้อมูล เราจึงจำเป็นต้องสร้างการโยกย้ายข้อมูลเพื่อปรับแก้ฐานข้อมูลให้ถูกต้อง:

```
dotnet ef migrations add AddItems
```

คำสั่งนี้จะสร้างการโยกย้ายข้อมูลขึ้นมาใหม่ในชื่อ `AddItems` โดยพิจารณาจากความเปลี่ยนแปลงใด ๆ ที่ได้กระทำไว้กับบริบทก่อนหน้านี้

> หากเกิดข้อผิดพลาดเช่น `No executable found matching command "dotnet-ef"`  แล้ว โปรดตรวจสอบว่าคุณอยู่ในไดเรกทอรีที่ถูกต้อง เนื่องจากคำสั่งเช่นนี้จะต้องรันที่ไดเรกทอรีรากเท่านั้น (ซึ่งเป็นที่อยู่ของไฟล์ `Program.cs`)

หากคุณเปิดไปที่ไดเรกทอรี `Data/Migrations` จะพบว่ามีไฟล์อยู่หลายไฟล์:

![Multiple migrations](migrations.png)

ไฟล์แรกของการโยกย้าย (ที่มีชื่อเช่น `00_CreateIdentitySchema.cs`) ถูกสร้างขึ้นมาและถูกเรียกใช้ตั้งแต่เมื่อครั้งรันคำสั่ง `dotnet new` ส่วนชื่อของการโยกย้าย `AddItem` ที่ถูกสร้างขึ้นมาใหม่จะถูกนำหน้าด้วยเวลาที่สร้าง 
> คุณสามารถเรียกดูรายการโยกย้ายทั้งหมดได้ด้วยคำสั่ง `dotnet ef migrations list`

หากเปิดดูในไฟล์การโยกย้าย คุณจะพบสองเมธอดชื่อ `Up` และ `Down`:

**Data/Migrations/<date>_AddItems.cs**

```csharp
protected override void Up(MigrationBuilder migrationBuilder)
{
    // (... some code)

    migrationBuilder.CreateTable(
        name: "Items",
        columns: table => new
        {
            Id = table.Column<Guid>(nullable: false),
            DueAt = table.Column<DateTimeOffset>(nullable: true),
            IsDone = table.Column<bool>(nullable: false),
            Title = table.Column<string>(nullable: true)
        },
        constraints: table =>
        {
            table.PrimaryKey("PK_Items", x => x.Id);
        });

    // (some code...)
}

protected override void Down(MigrationBuilder migrationBuilder)
{
    // (... some code)

    migrationBuilder.DropTable(
        name: "Items");

    // (some code...)
}
```

เมธอด `Up` จะรันเมื่อการโยกย้ายนั้น ๆ ถูกนำไปใช้กับฐานข้อมูล และเนื่องจากคุณได้เพิ่ม `DbSet<TodoItem>` เข้าไปยังบริบทฐานข้อมูลไว้แล้ว ดังนั้น Entity Framework Core จะสร้างตาราง `Items` (โดยมีคอลัมน์ที่สอดคล้องกับ `TodoItem`) เมื่อคุณดำเนินการโยกย้ายข้อมูล

เมธอด `Down` จะทำงานในทางตรงกันข้าม: หากคุณจำเป็นต้องยกเลิก (ย้อนคืน) การโยกย้ายข้อมูลแล้ว ตาราง `Items` ก็จะถูกลบทิ้งไป

### วิธีแก้ปัญหาจากข้อจำกัดของ SQLite

ใน SQLite มีข้อจำกัดบางประการที่อาจทำให้เกิดปัญหาได้หากคุณพยายามทำการโยกย้ายข้อมูลด้วยโค้ดที่เป็นอยู่ตอนนี้ จนกว่าจนกว่าข้อจำกัดดังกล่าวจะได้รับการแก้ไข เราสามารถแก้ปัญหาเบื้องต้นได้ดังนี้:

* ใส่หมายเหตุหรือลบบรรทัดที่มี `migrationBuilder.AddForeignKey` ในเมธอด `Up`
* ใส่หมายเหตุหรือลบบรรทัดใด ๆ ที่มี `migrationBuilder.DropForeignKey` ในเมธอด `Down`

หากคุณใช้ฐานข้อมูล SQL เต็มรูปแบบเช่น SQL Server หรือ MySQL ก็จะไม่มีปัญหาใด ๆ และไม่จำเป็นต้องใช้วิธีแก้ปัญหา (ที่ต้องยอมรับว่าออกจะเป็นการแฮกไปสักหน่อย) เช่นนี้

### ดำเนินการโยกย้ายข้อมูล

ขั้นตอนสุดท้ายหลังจากที่ได้สร้างการโยกย้ายข้อมูล (ซึ่งอาจมีมากกว่าหนึ่งการโยกย้ายก็ได้) คือการนำไปใช้กับฐานข้อมูล:

```
dotnet ef database update
```

คำสั่งนี้จะทำให้ Entity Framework Core สร้างตาราง `Items` ขึ้นในฐานข้อมูล

> หากต้องการย้อนคืน (roll back) สถานะของฐานข้อมูล คุณสามารถระบุชื่อของการโยกย้าย *ก่อนหน้า* :
> `dotnet ef database update CreateIdentitySchema`
> ซึ่งจะเป็นการรันเมธอด `Down` ของทุก ๆ การโยกย้ายที่ใหม่กว่าการโยกย้ายที่คุณระบุ

> หากคุณต้องการลบฐานข้อมูลออกทั้งหมดเพื่อเริ่มต้นใหม่ ให้รันคำสั่ง `dotnet ef database drop` แล้วตามด้วย `dotnet ef database update` เพื่อขึ้นโครงร่างของฐานข้อมูลขึ้นมาใหม่พร้อมทั้งทำให้อยู่ในสถานะเดียวกันกับการโยกย้ายล่าสุด

เรียบร้อยแล้ว! ตอนนี้ทั้งฐานข้อมูลและบริบทก็พร้อมใช้งานแล้ว อันดับถัดไป คุณจะได้นำบริบทไปใช้ในชั้นบริการของคุณ
