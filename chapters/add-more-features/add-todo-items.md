## เพิ่มรายการสิ่งที่ต้องทำ

เราจะทำให้ผู้ใช้สามารถเพิ่มสิ่งที่ต้องทำขึ้นมาใหม่ได้ โดยการวางฟอร์มง่าย ๆ ไว้ใต้รายการสิ่งที่ต้องทำ:

![Final form](final-form.png)

การเพิ่มความสามารถเช่นนี้จำเป็นต้องใช้หลายขั้นตอน ได้แก่:

* เพิ่มฟอร์มเข้าไปใน view
* สร้างแอคชันใหม่ให้กับ controller เพื่อรองรับฟอร์มดังกล่าว
* เพิ่มโค้ดไปยังชั้นบริการเพื่ออัพเดตฐานข้อมูล

### เพิ่มฟอร์มใหม่

ใน view `Views/Todo/Index.cshtml` ได้จองพื้นที่ไว้สำหรับฟอร์มสำหรับเพิ่มรายการไว้แล้ว:

```html
<div class="panel-footer add-item-form">
  <!-- TODO: Add item form -->
</div>
```

เพื่อเป็นการแยกส่วนงานต่าง ๆ ออกจากกัน เราจะสร้าง view ขึ้นมาเฉพาะส่วนหรือ **partial view** โดยเป็นไฟล์ที่แยกออกมาและทำหน้าที่เป็นส่วนหนึ่งของ view ที่มีขนาดใหญ่กว่า

สร้าง view ในชื่อ `AddItemPartial.cshtml`:

**Views/Todo/AddItemPartial.cshtml**

```html
@model TodoItem

<form asp-action="AddItem" method="POST">
    <label asp-for="Title">Add a new item:</label>
    <input asp-for="Title">
    <button type="submit">Add</button>
</form>
```

ตัวช่วยแท็ก `asp-action` สามารถสร้าง URL ในฟอร์ม เช่นเดียวกับการใช้ส่วนย่อย `<a>` ในกรณีนี้ ตัวช่วย `asp-action` จะถูกแทนที่ด้วยเส้นทางที่แท้จริงไปยัง `AddItem` ที่กำลังจะถูกสร้างขึ้น:

```html
<form action="/Todo/AddItem" method="POST">
```

การเพิ่มตัวช่วยแท็ก `asp-` ไปยังส่วนย่อย `<form>` เป็นการเพิ่มฟิลด์ซ่อนสำหรับเก็บโทเคนเพื่อการตรวจสอบ (verification token) เข้าไปยังฟอร์มอีกด้วย โทเคนเพื่อการตรวจสอบนี้สามารถนำมาใช้เพื่อป้องกันการโจมตีด้วยการปลอมแปลงคำร้องขอข้ามไซต์หรือ cross-site request forgery (CSRF) ได้ โดยเราจะได้ตรวจสอบโทเคนนี้ในขณะที่เขียนแอคชัน

นั่นคือทั้งหมดที่ต้องทำเพื่อสร้าง view เฉพาะส่วนหรือ partial view ซึ่งตอนนี้กำลังจะถูกอ้างถึงจากใน view หลัก Todo ของเรา:

**Views/Todo/Index.cshtml**

```html
<div class="panel-footer add-item-form">
  @await Html.PartialAsync("AddItemPartial", new TodoItem())
</div>
```

### เพิ่มแอคชัน

เมื่อผู้ใช้คลิก Add บนฟอร์มที่เพิ่งสร้างขึ้นมานี้ เบราว์เซอร์จะส่งคำขอ POST ไปยัง `/Todo/AddItem` ในแอปพลิเคชันของเรา ซึ่งจะยังไม่สามารถทำงานได้ในตอนนี้เนื่องจากไม่มีแอคชันที่สามารถดำเนินการกับเส้นทาง `/Todo/AddItem` ได้ หากคุณลองคลิกตอนนี้ ASP.NET Core จะแสดงข้อผิดพลาด `404 Not Found` ขึ้นมา

เราจึงต้องสร้างแอคชันในชื่อ `AddItem` ไว้บน `TodoController`:

```csharp
[ValidateAntiForgeryToken]
public async Task<IActionResult> AddItem(TodoItem newItem)
{
    if (!ModelState.IsValid)
    {
        return RedirectToAction("Index");
    }

    var successful = await _todoItemService.AddItemAsync(newItem);
    if (!successful)
    {
        return BadRequest("Could not add item.");
    }

    return RedirectToAction("Index");
}
```

เห็นวิธีที่แอคชัน `AddItem` รับค่าพารามิเตอร์ `TodoItem` นั่นไหม? นี่คือ model `TodoItem` เดียวกันที่เราสร้างขึ้นมาในบท _พื้นฐานของ MVC_ เพื่อใช้เก็บข้อมูลสิ่งที่ต้องทำ เมื่อถูกนำมาใช้ในที่นี้เป็นพารามิเตอร์ของแอคชัน แล้ว ASP.NET Core จะทำกระบวนการที่เรียกว่าการจับคู่โมเดลหรือ **model binding** ให้โดยอัตโนมัติ

การจับคู่โมเดลจะพิจารณาข้อมูลในคำขอและพยายามจับคู่ฟิลด์ที่รับเข้ามาเข้ากับคุณสมบัติของโมเดลที่สอดคล้องกันอย่างชาญฉลาด อาจกล่าวได้อีกอย่างว่าเมื่อผู้ใช้ส่งฟอร์มและเบราว์เซอร์ POST มาที่แอคชันนี้ ASP.NET Core จะรับค่าต่าง ๆ มาจากฟอร์มมาใส่ไว้ในตัวแปร `newItem`

คุณลักษณะ `[ValidateAntiForgeryToken]` ที่วางไว้ก่อนแอคชันจะบอกให้ ASP.NET Core รู้ว่าควรมองหา (และตรวจสอบ) โทเคนเพื่อการตรวจสอบที่ซ่อนอยู่ ซึ่งถูกเพิ่มเข้ามาในฟอร์มโดยตัวช่วยแท็ก `asp-action` นี่เป็นมาตรการด้านความปลอดภัยที่สำคัญสำหรับป้องกันการโจมตีด้วยการปลอมแปลงคำร้องขอข้ามไซต์หรือ cross-site request forgery (CSRF) ซึ่งผู้ใช้อาจถูกล่อลวงให้ส่งข้อมูลจากไซต์ที่ไม่หวังดีเข้ามาได้ โดยโทเคนเพื่อการตรวจสอบนี้ช่วยให้มั่นใจได้ว่าแอปพลิเคชันของเราเป็นผู้ที่สร้างและส่งฟอร์มนี้จริง ๆ

ไปดูที่ view `AddItemPartial.cshtml` กันอีกครั้ง บรรทัด `@model TodoItem` ที่ตอนต้นของไฟล์บอก ASP.NET Core ว่า view ดังกล่าวถูกคาดหวังว่าจะต้องถูกจับคู่กับ model `TodoItem` ซึ่งทำให้สามารถใช้ `asp-for="Title"` ในแท็ก `<input>` เพื่อบอก ASP.NET Core ให้รู้ว่าส่วนย่อย input นี้เป็นของคุณสมบัติ `Title`

เนื่องจากมีบรรทัด `@model` อยู่ view เฉพาะส่วนนี้จึงคาดหวังว่าจะได้รับวัตถุ `TodoItem` เข้ามาขณะที่ view กัำลังถูกสร้างขึ้น การส่ง `new TodoItem` ผ่าน `Html.PartialAsync` เช่นนี้ จะทำให้ได้ฟอร์มที่มีรายการว่างขึ้นมา (ลองเพิ่ม `{ Title = "hello" }` เข้าไป และดูว่าเกิดอะไรขึ้น!)

ระหว่างการจับคู่โมเดล คุณสมบัติใด ๆ ของโมเดลที่ไม่สามารถจับคู่กับฟิลด์ในคำขอได้จะถูกละไว้ และเนื่องจากฟอร์มนี้มีเพียงส่วนย่อย input `Title` เพียงอย่างเดียว เราจึงคาดได้ว่าคุณสมบัติอื่น ๆ ของ `TodoItem` (แฟลก `IsDone` แวะวันที่ `DueAt`) จะถูกปล่อยว่างไว้หรือคงสถานะเป็นค่าตั้งค้นที่ถูกกำหนดไว้

> แทนที่จะใช้โมเดล `TodoItem` ซ้ำ อีกแนวทางหนึ่งคือสร้างโมเดลขึ้นมาใหม่ (เช่น `NewTodoItem`) ที่ถูกใช้สำหรับแอคชันนี้เพียงอย่างเดียวและมีเพียงคุณสมบัติเท่าที่จำเป็นต้องใช้ (Title) เพื่อสร้างสิ่งที่ต้องทำขึ้นมาใหม่เท่านั้น การจับคู่โมเดลยังคงถูกเรียกใช้ แต่ด้วยวิธีนี้เราจะได้แยกโมเดลที่ถูกใช้เพื่อเก็บข้อมูลรายการสิ่งที่ต้องทำลงในฐานข้อมูลออกจากโมเดลที่ใช้จับคู่กับข้อมูลที่มาจากคำขอผ่านเว็บ วิธีเช่นนี้อาจเรียกได้ว่าเป็น **โมเดลเพื่อการจับคู่ (binding model)** หรือเป็น **วัตถุเพื่อการส่งผ่านข้อมูล (data transfer object)** (DTO) ซึ่งเป็นแบบแผนที่นิยมใช้กันในโปรเจกต์ที่มีขนาดใหญ่และมีความซับซ้อนสูง

หลังจากจับคู่ข้อมูลคำขอเข้ากับโมเดลแล้ว ASP.NET Core จะทำการ **ตรวจสอบโมเดล (model validation)** ซึ่งจะตรวจสอบว่าข้อมูลที่ถูกจับคู่เข้ากับโมเดลนั้นใช้ได้หรือสมเหตุสมผลหรือไม่ เราสามารถเพิ่มข้อกำหนดต่าง ๆ เข้าไปในโมเดลได้ เพื่อบอก ASP.NET Core ว่าควรดำเนินการตรวจสอบอย่างไร

ข้อกำหนด `[Required]` ในคุณสมบัติ `Title` บอกส่วนที่ดำเนินการตรวจสอบของ ASP.NET Core ให้พิจารณาว่าหัวข้อหรือ title นี้ไม่สามารถใช้ได้หากถูกปล่อยให้ว่างไว้หรือไม่ได้ส่งมาด้วย ลองดูที่โค้ดของแอคชัน `AddItem`: บล็อกแรกสุดจะตรวจสอบว่า `ModelState` (ผลของการตรวจสอบโมเดล) นั้นใช้ได้หรือไม่ ในทางปฏิบัติแล้ว การตรวจสอบนี้จะถูกกระทำที่จุดเริ่มต้นของแอคชัน:

```csharp
if (!ModelState.IsValid)
{
    return RedirectToAction("Index");
}
```

ถ้า `ModelState` เป็นเท็จไม่ว่าด้วยเหตุผลใด ๆ เบราว์เซอร์จะถูกกำหนดให้เปลี่ยนไปเปิดเส้นทาง `/Todo/Index` แทน ซึ่งจะโหลดหน้าดังกล่าวขึ้นมาใหม่อีกครั้ง

อันดับต่อไป controller จะเรียกไปยังชั้นบริการให้ดำเนินการบันทึกรายการสิ่งที่ต้องทำใหม่นี้ลงในฐานข้อมูลจริง ๆ:

```csharp
var successful = await _todoItemService.AddItemAsync(newItem);
if (!successful)
{
    return BadRequest(new { error = "Could not add item." });
}
```

เมธอด `AddItemAsync` จะคืนค่าเป็น `true` หรือ `false` ขึ้นอยู่กับว่ารายการดังกล่าวสามารถเพิ่มเข้าไปยังฐานข้อมูลได้สำเร็จหรือไม่ หากไม่สำเร็จด้วยเหตุผลใด ๆ แอคชันนี้จะคืนค่าผิดพลาด HTTP `400 Bad Request` ไปพร้อมกับวัตถุที่มีข้อความแสดงความผิดพลาด

ท้ายที่สุด หากทุกอย่างดำเนินการสำเร็จโดยไม่มีข้อผิดพลาด แอคชันจะเปลี่ยนเส้นทางให้เบราว์เซอร์เปิดไปยัง `/Todo/Index` ซึ่งจะโหลดหน้าซ้ำอีกครั้ง พร้อมทั้งแสดงรายการสิ่งที่ต้องทำที่ถูกอัพเดตแล้วให้กับผู้ใช้

### เพิ่มเมธอดบริการ

หากคุณใช้โปรแกรมแก้ไขโค้ดที่เข้าใจภาษา C# คุณจะเห็นเส้นหยักสีแดงใต้ `AddItemAsync` เนื่องจากยังไม่มีเมธอดดังกล่าวอยู่จริง

ดังนั้นในขั้นตอนนี้เราจำเป็นต้องเพิ่มเมธอดเข้าไปในชั้นบริการ  อันดับแรก ให้เพิ่มเข้าไปยังส่วนของการกำหนดอินเตอร์เฟสใน `ITodoItemService`:

```csharp
public interface ITodoItemService
{
    Task<TodoItem[]> GetIncompleteItemsAsync();

    Task<bool> AddItemAsync(TodoItem newItem);
}
```

จากนั้น ให้เขียนส่วนของการนำไปปฏิบัติไว้ใน `TodoItemService`:

```csharp
public async Task<bool> AddItemAsync(TodoItem newItem)
{
    newItem.Id = Guid.NewGuid();
    newItem.IsDone = false;
    newItem.DueAt = DateTimeOffset.Now.AddDays(3);

    _context.Items.Add(newItem);

    var saveResult = await _context.SaveChangesAsync();
    return saveResult == 1;
}
```

เนื่องจากคุณสมบัติ `newItem.Title` ถูกกำหนดไว้จากการจับคู่โมเดลที่กระทำโดย ASP.NET Core แล้ว ดังนั้นเมธอดนี้จึงต้องทำเพียงแค่การกำหนดค่า ID และค่าตั้งต้นสำหรับคุณสมบัติอื่น ๆ จากนั้น รายการใหม่นี้จะถูกเพิ่มไปยังบริบทฐานข้อมูล แต่จะยังไม่ถูกบันทึกจริง ๆ จนกล่าวจะเรียก `SaveChangesAsync()` หากการบันทึกกระทำได้สำเร็จ `SaveChangesAsync()` จะคืนค่าเป็น 1

### มาทดสอบกัน

ให้รันแอปพลิเคชันแล้วเพิ่มรายการสิ่งที่ต้องทำสองถึงสามรายการโดยใช้ฟอร์มที่สร้างขึ้น และเนื่องจากสิ่งที่ต้องทำดังกล่าวถูกจัดเก็บลงในฐานข้อมูล รายการทั้งหมดนี้จึงจะคงอยู่แม้แอปพลิเคชันจะถูกปิดและเปิดใหม่ก็ตาม

> ลองท้าทายตนเองเพิ่มเติมด้วยการเพิ่มปฏิทิน (date picker) โดยใช้ HTML และจาวาสคริปต์ และให้ผู้ใช้เลือกวันที่ (หรือจะไม่เลือกก็ได้) สำหรับคุณสมบัติ `DueAt` จากนั้น ให้ใช้วันที่ดังกล่าวแทนที่จะกำหนดให้งานใหม่ทุกงานครบกำหนดใน 3 วัน
